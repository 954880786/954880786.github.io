<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[《Fluent Python》读书笔记 —— 第一章 数据结构]]></title>
      <url>%2F2017%2F12%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
      <content type="text"><![CDATA[《Fluent Python》读书笔记 —— 第一章 数据结构1. 序列构成的数组可变序列与不可变序列可变序列 list, bytearray, array.array, collections.deque, memoryview 不可变序列 tuple, str, bytes 笛卡尔积 — 列表推导式的嵌套12345&gt;&gt;&gt; colors = ['blacklack', 'red']&gt;&gt;&gt; sizes = ['M', 'S', 'L']&gt;&gt;&gt; tshirts = [(color, size) for color in colors for size in sizes]&gt;&gt;&gt; tshirts[('blacklack', 'M'), ('blacklack', 'S'), ('blacklack', 'L'), ('red', 'M'), ('red', 'S'), ('red', 'L')] 生成器表达式1&gt;&gt;&gt; tshirts = ((color, size) for color in colors for size in sizes) 元组拆包（python3）123456&gt;&gt;&gt; a, b, *rest = range(5)&gt;&gt;&gt; a, b, rest(0, 1, [2, 3, 4])&gt;&gt;&gt; a, *body, c, d = range(5)&gt;&gt;&gt; a, *body, c, d(0, 1, 2, 3, 4) 具名元组定义元组，需要两个参数，第一个参数是类名，另一个是类的各个字段的名字。后者可以是由数个字符串组成的可迭代对象，或者是由空格隔开的字段名组成的字符串 12&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; City = namedtuple('City', 'name country population coordinates') 具名元组的使用 123456789&gt;&gt;&gt; tokyo = City('Tokyo', 'JP', 36.933, (35.6, 139.6))&gt;&gt;&gt; tokyoCity(name='Tokyo', country='JP', population=36.933, coordinates=(35.6, 139.6))&gt;&gt;&gt; tokyo.name'Tokyo'&gt;&gt;&gt; tokyo.population36.933&gt;&gt;&gt; tokyo[1]'JP' 具名元组的常用的属性和方法(_fields, _make(), _asdict()) 123456789&gt;&gt;&gt; City._fields('name', 'country', 'population', 'coordinates')&gt;&gt;&gt; LatLong = namedtuple('LatLong', 'lat long')&gt;&gt;&gt; delhi_data = ('Delhi NCR', 'IN', 21.3, LatLong(28.3, 77.2))&gt;&gt;&gt; delhi = City._make(delhi_data)&gt;&gt;&gt; delhi._asdict()OrderedDict([('name', 'Delhi NCR'), ('country', 'IN'), ('population', 21.3), ('coordinates', LatLong(lat=28.3, long=77.2))])&gt;&gt;&gt; delhiCity(name='Delhi NCR', country='IN', population=21.3, coordinates=LatLong(lat=28.3, long=77.2)) 切片切片是一个对象 123&gt;&gt;&gt; SK = slice(1, 3)&gt;&gt;&gt; range(10)[SK]range(1, 3) 给切片赋值(原切片长度与赋值切片长度不需要相等) 12345&gt;&gt;&gt; l = range(10)&gt;&gt;&gt; l = list(range(10))&gt;&gt;&gt; l[1:4] = [8, 5, 4]&gt;&gt;&gt; l[0, 8, 5, 4, 4, 5, 6, 7, 8, 9] 建立由列表组成的列表，正确的方法 1&gt;&gt;&gt; example = [[[0] * 4] for i in range(3)] 错误的方法，他们都指向同一个对象 1234&gt;&gt;&gt; example = [[0] * 4] * 3&gt;&gt;&gt; example[0][0] = 998&gt;&gt;&gt; example[[998, 0, 0, 0], [998, 0, 0, 0], [998, 0, 0, 0]] 序列的增量赋值增量赋值运算符 += 和 *= 取决于他们第一个操作对象，关键在于对象是否实现了(__iadd__, __imul__, )等”就地“方法。如果该对象实现了”就地“方法，就会调用它们原地修改对象而不生成新对象。如果该对象没有实现”就地“方法，就会退一步调用(__add__, __mul__)等方法，就像a = a + b一样生成一个新的对象 用bisect来管理已排序的序列bisect模块有两个主要函数bisect和insort bisect返回待插入位置(返回的是跟它相等的元素之后的位置，与之相对的是bisect_left) 1234&gt;&gt;&gt; bisect.bisect([1, 4, 5, 6, 8, 8, 9], 8)6&gt;&gt;&gt; bisect.bisect_left([1, 4, 5, 6, 8, 8, 9], 8)4 insort 保持插入一个数后依旧使数组升序 1234&gt;&gt;&gt; a = [1, 4, 5, 6, 8, 8, 9]&gt;&gt;&gt; bisect.insort(a, 5)&gt;&gt;&gt; a[1, 4, 5, 5, 6, 8, 8, 9] 除数组以外的数据结构array数组只能存放同一个类型的数据，高效，节约存储空间 12&gt;&gt;&gt; from array import array&gt;&gt;&gt; floats = array('d', (random() for i in range(10**7))) collections.deque双端队列O(1)复杂度从两端添加或者删除元素， O(n)复杂度随机取值 1234567891011121314&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; dq = deque(range(10), maxlen=10)&gt;&gt;&gt; dqdeque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)&gt;&gt;&gt; dq.rotate(3)&gt;&gt;&gt; dqdeque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6], maxlen=10)&gt;&gt;&gt; dq.pop()6&gt;&gt;&gt; dqdeque([7, 8, 9, 0, 1, 2, 3, 4, 5], maxlen=10)&gt;&gt;&gt; dq.append(998)&gt;&gt;&gt; dqdeque([7, 8, 9, 0, 1, 2, 3, 4, 5, 998], maxlen=10) queue提供了线程安全队列 heapq可以当作堆队列，优先队列，有 heappush, heappop等方法 2. 字典集合字典推导1234&gt;&gt;&gt; data = [('a', 1), ('b', 2), ('c', 3)]&gt;&gt;&gt; datamap = &#123;c: num for c, num in data&#125;&gt;&gt;&gt; datamap&#123;'a': 1, 'b': 2, 'c': 3&#125; setdefault1&gt;&gt;&gt; my_dict.setdefault(key, []) defaultdict某个键在映射中不存在的时候，该字典会为之填充一个默认值 12&gt;&gt;&gt; my_dict = collections.defaultdict(list)&gt;&gt;&gt; my_dict[key].append(num) 特殊方法__missing__当__getitem__方法无法找到键时会调用该方法 不可变的映射类型通过MappingProxyType可以返回一个只读的映射视图，但它是动态的。这意味着如果我们对原映射做出了改动，我们可以通过这个试图观察到。 1234567891011121314&gt;&gt;&gt; from types import MappingProxyType&gt;&gt;&gt; d = &#123;1: 'A'&#125;&gt;&gt;&gt; d_proxy = MappingProxyType(d)&gt;&gt;&gt; d_proxymappingproxy(&#123;1: 'A'&#125;)&gt;&gt;&gt; d_proxy[1]'A'&gt;&gt;&gt; d_proxy[2] ='x'Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'mappingproxy' object does not support item assignment&gt;&gt;&gt; d[2] = 'B'&gt;&gt;&gt; d_proxymappingproxy(&#123;1: 'A', 2: 'B'&#125;) 集合推导123&gt;&gt;&gt; my_set = &#123;chr(i) for i in range(32, 64)&#125;&gt;&gt;&gt; my_set&#123;'0', '&lt;', '!', '9', '.', '4', '+', ';', '-', '=', '(', ':', ',', '2', '"', '1', '#', '*', '/', '%', '&amp;', '$', '8', '&gt;', '3', "'", ')', '5', '?', ' ', '6', '7'&#125; 集合的常见操作s, z为两个集合 e为元素 交集 s &amp; z , 并集 s | z, 差集 s - z, 对称差集 s ^ z 子集 s &lt;= z, 真子集 s &lt; z dict的实现及其导致的结果 键必须是可散列的 字典在内存上的开销巨大，若确定键可以采用namedtuple取代 键查询很快 键的顺序没有规律 ​ 3. 文本和字节序列码位：即字符的标识，python3中采用的是unicode码 字节序列：将字符按照某种编码方式(如utf-8等)编码成的字节序列，\x41 把码位转换成字节序列的过程是编码，把字节序列转化成码位的过程是解码 python3 的str对象是unicode字符，这相当于python2的unicode对象中的元素，python2中的str对象是原始的字节序列。其编码是与系统环境相关的，一般就是sys.getfilesystemencoding()得到的值 输出到终端时应与终端输出编码一致. 12345print sys.getdefaultencoding() #系统默认编码print sys.getfilesystemencoding() #文件系统编码print locale.getdefaultlocale() #系统当前编码print sys.stdin.encoding #终端输入编码print sys.stdout.encoding #终端输出编码 为什么会出现编码问题？ 根本原因在于字符串的编码格式与环境默认格式不一致，导致python将其输出到控制台或者文件中时，仍旧按照默认编码格式读写字符串，会造成乱码或者出错的情况。 对unicode类型进行解码，对str类型进行编码 直接以unicode格式写入文件 编码或者解码的格式不符 (当然如果默认编码格式正好是字符串编码格式的父集时不会出现乱码或者出错的情形) 如何解决字符编码问题? 使用*unix系统 在python内部始终使用unicode格式，读入文件时将其解码(decode)转换成unicode，写入文件时将其编码(encode)成对应格式，程序内部的字符串格式统一为unicode。 可以采用chardet检测编码 切换python的默认编码格式 123import sys reload(sys) sys.setdefaultencoding('gbk') 忽略异常值 1s.decode('gbk','ignore').encode('utf-8′) 以下摘抄自 [!https://www.v2ex.com/t/339142] author: lzjun Python2 字符类型在 python2 中和字符串相关的数据类型有 str 和 unicode 两种类型，它们继承自 basestring ，而 str 类型的字符串的编码格式可以是 ascii 、 utf-8 、 gbk 等任何一种类型。 对于汉字『好』，用 str 表示时，它对应的 utf-8 编码 是’\xe5\xa5\xbd’，对应的 gbk 编码是 ‘\xba\xc3’，而用 unicode 表示时，他对应的符号就是 u’\u597d’，与 u”好” 是等同的。 str 与 unicode 的转换在 Python 中 str 和 unicode 之间是如何转换的呢？这两种类型的字符串之间的转换就是靠 decode 和 encode 这两个函数。 encode 负责将 unicode 编码成指定的字符编码，用于存储到磁盘或传输到网络中。而 decode 方法是根据指定的编码方式解码后在应用程序中使用。 12345678910111213141516 #从 unicode 转换到 str 用 encode&gt;&gt;&gt; b = u'好'&gt;&gt;&gt; c = b.encode('utf-8')&gt;&gt;&gt; type(c)&lt;type 'str'&gt;&gt;&gt;&gt; c'\xe5\xa5\xbd'#从 str 类型转换到 unicode 用 decode&gt;&gt;&gt; d = c.decode('utf-8')&gt;&gt;&gt; type(d)&lt;type 'unicode'&gt;&gt;&gt;&gt; du'\u597d' UnicodeXXXError 错误的原因在字符编码转换操作时，遇到最多的问题就是 UnicodeEncodeError 和 UnicodeDecodeError 错误了，这些错误的根本原因在于 Python2 默认是使用 ascii 编码进行 decode 和 encode 操作，例如： case 112345&gt;&gt;&gt; s = '你好'&gt;&gt;&gt; s.decode()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128) 当把 s 转换成 unicode 类型的字符串时， decode 方法默认使用 ascii 编码进行解码，而 ascii 字符集中根本就没有中文字符『你好』，所以就出现了 UnicodeDecodeError ，正确的方式是显示地指定 UTF-8 字符编码。 12&gt;&gt;&gt; s.decode('utf-8')u'\u4f60\u597d' 同样地道理，对于 encode 操作，把 unicode 字符串转换成 str 类型的字符串时，默认也是使用 ascii 编码进行编码转换的，而 ascii 字符集找不到中文字符『你好』，于是就出现了 UnicodeEncodeError 错误。 12345&gt;&gt;&gt; a = u'你好'&gt;&gt;&gt; a.encode()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) case 2str 类型与 unicode 类型的字符串混合使用时， str 类型的字符串会隐式地将 str 转换成 unicode 字符串，如果 str 字符串是中文字符，那么就会出现 UnicodeDecodeError 错误，因为 python2 默认会使用 ascii 编码来进行 decode 操作。 123456&gt;&gt;&gt; s = '你好' # str 类型&gt;&gt;&gt; y = u'python' # unicode 类型&gt;&gt;&gt; s + y # 隐式转换，即 s.decode('ascii') + uTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 0: ordinal not in range(128) 正确地方式是显示地指定 UTF-8 字符编码进行解码 12&gt;&gt;&gt; s.decode('utf-8') +yu'\u4f60\u597dpython' 乱码所有出现乱码的原因都可以归结为字符经过不同编码解码在编码的过程中使用的编码格式不一致，比如： 12345678910111213# encoding: utf-8&gt;&gt;&gt; a&gt;&gt;&gt; a'\xe5\xa5\xbd'&gt;&gt;&gt; b=a.decode("utf-8")&gt;&gt;&gt; bu'\u597d'&gt;&gt;&gt; c=b.encode("gbk")&gt;&gt;&gt; c'\xba\xc3'&gt;&gt;&gt; print c�� utf-8 编码的字符‘好’占用 3 个字节，解码成 Unicode 后，如果再用 gbk 来解码后，只有 2 个字节的长度了，最后出现了乱码的问题，因此防止乱码的最好方式就是始终坚持使用同一种编码格式对字符进行编码和解码操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017机器学习面经总结]]></title>
      <url>%2F2017%2F12%2F08%2F2017%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[2017机器学习面经总结写了一波面经，回馈一波社会= = (未按时间顺序排序) (17暑假)今日头条二面(一面忘了…)： scikit-learn 中LR 常用分类核 项目 LR 的损失函数 一个增序数组，将后面K个数（K不告诉你）整体移至数组前面，现在给你一个数用logn的复杂度判断这个数是否在数组中 什么情况下会过拟合，怎样解决过拟合 SVM中核的作用，有哪些核，SVM相对于LR的优缺点 百度NLP一面(各种问算法)： m个平均长度为n的逆序数组，求出出现次数最多的TopK个数 中缀转后缀实现四则+括号的计算器 实现类似tensorflow的运算图的库有哪些较好的数据结构，如何设计 rnn公式，lstm原理 vim中你常见的快捷键有哪些。。。（wetyuiopadghjklcb) 百度NLP二面(各种问算法)： 实习项目 Z型层次遍历树 不用额外空间的字符串逆序 检查是否可以使用字典里的词语匹配字符串(最优解为DP) 开放题：如果让你给一篇文章打tags，有哪些方面(比如文章的分类，关键词等)可以考虑 搜狐大数据中心一面： 详问实习项目，每个epoch的训练时间？ 项目：聚类方法(single-pass)，相似度计算方法，怎样优化O(n2)的相似度计算 协同过滤的基本原理 对图片型数据的常见预处理操作有哪些 bathnormsize和dropout层如何实现的，有什么作用，为什么能有作用 keras中卷积层和池化层有哪些常见的模式(比如same等) 面试官好像分不清你电和西电2333 二面问我是否考虑其他大数据研发部门？？直接拒了网易有道一面(小姐姐，问的都很基础)： 实习项目 常见的bash命令，git命令 常用的分类、聚类算法有哪些 怎样避免梯度爆炸和梯度弥散，为什么会发生 特征工程是什么，如何去做特征工程 机器学习相关常用的开源库有哪些 CNN常用的卷积核大小，stride是什么 数据增强有哪些常见操作 网易有道二面(还是小姐姐，纸上写代码然后拍照= =)： 实习项目 RF相对于决策树有哪些改动 什么情况下会过拟合，怎样解决过拟合 boosting和bagging各自做简单介绍，有何区别 判断在一棵二叉树中是否有相同的子结构，如果有找出有多少对相同的子结构（比如一棵二叉树的左右结点是两颗相同的子树就算一对） 京东一面(时间很短)： 项目 比赛获奖项目是什么，比赛的级别是什么 什么情况下会过拟合，怎样解决过拟合 实习项目 链表是否存在环，若是求出环的入口点 京东二面(时间很短)： 项目 实习项目：为什么不采用模型融合 著名的深度神经网络结构（如vgg16等） 求一颗二叉树中TopK深度的结点 头条推荐算法： 组长直接帮我推过去了= =，所以最后还是回头条去了=。= (头条技术小哥好评啊)]]></content>
    </entry>

    
  
  
</search>
